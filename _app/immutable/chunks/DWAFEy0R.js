import{b as p,f as i}from"./CPkCZXMv.js";import"./BqWBCiSB.js";import{ae as o,af as _,ag as l,ah as n,ai as d}from"./jexLX7L2.js";import{h as r}from"./BY30b_Np.js";const g={title:"What is Svelte?",date:"2026-02-10T00:00:00.000Z",description:null,image:"../../static/images/108b0afde79cc38220cf823d6c0c20e0_MD5.jpg",tags:["Svelte"],draft:!1},{title:M,date:O,description:P,image:T,tags:V,draft:D}=g;var h=i(`<p>React나 Vue를 써봤다면 한 번쯤 이런 생각 해보셨을 겁니다. <em>“왜 이렇게 번들이 무겁지?”</em> 스벨트(Svelte)는 바로 그 지점에서 출발합니다. React, Vue와 함께 현대 웹 프런트엔드를 이끄는 주요 기술이지만, 동작 방식이 근본적으로 다릅니다.</p> <p>가장 쉽게 설명하면 <strong>“언제 동작하느냐”</strong> 의 차이입니다.</p> <p>React와 Vue는 배포 시 해당 라이브러리 자체가 번들에 포함됩니다. 그래서 브라우저에서 실행되는 내내 프레임워크가 함께 동작하며, 화면이 바뀔 때마다 가상 DOM을 통해 변경된 부분을 계산합니다. 반면 스벨트는 배포 전 컴파일 시점에 이미 그 작업을 끝내버리기 때문에, 브라우저에는 순수 자바스크립트만 전달됩니다. 프레임워크가 런타임에 껴있지 않으니 그만큼 가볍고 빠릅니다.</p> <p>덕분에 번들 크기가 작고, 브라우저 자원을 훨씬 효율적으로 씁니다.
특히 성능에 민감한 환경이나 가벼운 프로젝트라면 스벨트 도입이 괜찮습니다.</p> <p>다만 현실적인 한계도 있습니다. 아직 생태계와 서드파티 라이브러리가 React에 비해 부족한 편이라, 실무에서 도입할 때는 이 부분을 꼭 고려해야 합니다.</p> <p><img src="../../static/images/646b57713e09c8ad32f934f3deaef2c2_MD5.jpg"/></p> <h2>Svelte vs React: 설계 철학 비교</h2> <p>두 기술의 구조적 차이와 설계 철학에 대해 보다 깊이 있는 탐구를 원하시는 분들께 아래의 글을 추천드립니다.</p> <ul><li><strong>참고 자료:</strong> <a href="https://maddevs.io/blog/svelte-vs-react/" rel="nofollow">Svelte VS React의 철학</a></li></ul> <h2>개발 환경 설정 가이드</h2> <p>Svelte는 오직 코드에만 집중할 수 있도록 매우 간결한 시작 방법을 제공합니다. 웹 브라우저에서 즉시 실습하거나, 로컬 PC에 안정적인 작업 공간을 마련하는 두 가지 방법을 소개해 드립니다.</p> <h3>웹 브라우저에서 즉시 진행(Playground)</h3> <p><strong>Svelte</strong>는 별도의 로컬 설정 없이도 웹에서 즉시 코드를 작성하고 결과를 확인할 수 있는 실습 환경(REPL)을 제공합니다. 해당 환경을 통해 스벨트의 문법을 직접 구현해보고, 컴파일러가 생성하는 결과물을 실시간으로 확인해 보실 수 있습니다.</p> <ul><li><strong>URL:</strong> <a href="https://svelte.dev/playground" rel="nofollow">https://svelte.dev/playground</a></li></ul> <h3>로컬 개발 환경 구축하기 (Mac 기준)</h3> <p>터미널을 통해 몇 가지 명령어만으로 Svelte 프로젝트를 즉시 시작할 수 있습니다.</p> <ol><li><strong>사전 준비</strong> : 먼저 시스템에 <strong>Node.js</strong>와 <strong>npm</strong>이 설치되어 있는지 확인이 필요합니다. 터미널을 열고 아래 명령어를 입력하여 버전을 체크해 주세요</li></ol> <pre class="language-undefined"><!></pre> <ol start="2"><li><strong>프로젝트 생성</strong>: Svelte 프로젝트를 생성하기 위해 가장 널리 쓰이는 빌드 도구인 <strong>Vite</strong>를 활용합니다. 터미널에 다음 명령어를 입력해 주세요.</li></ol> <pre class="language-bash"><!></pre> <blockquote><p><strong>설정 팁:</strong> 명령어를 입력하면 프레임워크 선택 화면이 나타납니다. <code>Svelte</code>를 선택하신 후, 선호에 따라 <code>JavaScript</code> 또는 <code>TypeScript</code>를 선택해 주시면 됩니다.</p></blockquote> <ol start="3"><li><strong>의존성 설치 및 실행</strong>:  생성된 프로젝트 폴더로 이동하여 필요한 패키지들을 설치하고 개발 서버를 가동합니다.</li></ol> <pre class="language-bash"><!></pre> <p>모든 과정이 완료되었다면 브라우저 주소창에 <code>http://localhost:5173</code>을 입력해 보세요.</p>`,1);function S(t){var e=h(),a=o(_(e),34),u=l(a);r(u,()=>`<code class="language-undefined">node -v
npm -v</code>`),n(a);var s=o(a,4),m=l(s);r(m,()=>'<code class="language-bash"><span class="token function">npm</span> create vite@latest my-svelte-app</code>'),n(s);var c=o(s,6),f=l(c);r(f,()=>`<code class="language-bash"><span class="token comment"># 프로젝트 폴더로 이동 </span>
<span class="token builtin class-name">cd</span> my-svelte-app 

<span class="token comment"># 필요한 패키지 설치 </span>
<span class="token function">npm</span> <span class="token function">install</span> 

<span class="token comment"># 개발 서버 실행 </span>
<span class="token function">npm</span> run dev</code>`),n(c),d(2),p(t,e)}const x=Object.freeze(Object.defineProperty({__proto__:null,default:S,metadata:g},Symbol.toStringTag,{value:"Module"})),v={title:"Svelte에서 반응형을 제어하는 방법",date:null,description:null,image:"../../static/images/108b0afde79cc38220cf823d6c0c20e0_MD5.jpg",tags:["Svelte","Reactivity"],draft:!0},{title:q,date:w,description:z,image:E,tags:I,draft:L}=v;var b=i("<h2>반응형 변수란 무엇일까요?</h2> <p>웹 개발을 하다 보면 데이터의 변화에 맞춰 화면(UI)이 자연스럽게 업데이트되어야 하는 순간이 많습니다. 반응형(Reactivity)이란 바로 이렇게 상태가 변할 때 프레임워크가 이를 감지하여 알아서 화면을 갱신해 주는 편리한 개념을 말합니다. 개발자가 일일이 화면을 바꾸는 코드를 작성하지 않아도 되므로, 코드의 흐름이 훨씬 간결해집니다.</p> <h2>Svelet 4 이전까지 반응형 제어</h2> <p>Svelte는 그동안 이 반응형 제어를 매우 직관적으로 풀어내어 많은 사랑을 받았습니다. Svelte 4까지는 컴파일러가 알아서 코드의 의도를 파악하고 반응성을 부여해 주었죠. 단순히 <code>let</code> 키워드로 변수를 선언하고 값을 할당하기만 하면, Svelte가 컴파일 단계에서 이를 감지해 주었기 때문에 별도의 복잡한 설정 없이도 편안하게 개발을 진행할 수 있었습니다.</p> <h2>Svelte 5부터 Runes 도입</h2> <p>Svelte 컴파일러가 많은 부분을 묵묵히 처리해 주던 기존 방식에서 한 걸음 더 나아가, Svelte 5부터는 ‘룬(Runes)‘이라는 새로운 문법을 도입하게 됩니다. Svelte의 창시자인 리치 해리스(Rich Harris)는 공식 사이트의 ‘Introducing Runes’라는 글을 통해, 이러한 인상적인 변화가 필요했던 이유를 다음 세 가지 측면에서 차분하게 설명하고 있습니다.</p> <ul><li><strong>반응성 로직의 분리 한계 (“Reactivity is leaking”):</strong> 기존의 반응성은 주로 <code>.svelte</code> 파일 내부에서만 동작했습니다. 이로 인해 비즈니스 로직을 외부 파일로 깔끔하게 분리하고 재사용하는 데에 다소 아쉬운 점이 있었지만, 룬을 통해 이러한 제약을 부드럽게 해결할 수 있게 되었습니다.</li> <li><strong>대규모 애플리케이션에서의 효율성 (“Efficiency at scale”):</strong> 데이터의 규모가 큰 리스트 등에서는 아주 작은 값 하나만 바뀌어도 컴포넌트 전체를 다시 확인해야 하는 아쉬움이 있었습니다. 룬은 더욱 세밀한 제어를 가능하게 하여, 필요한 부분만 정확하게 업데이트하는 성능적인 이점을 제공합니다.</li> <li><strong>의존성 파악의 명확화 (“The $ paradox”):</strong> 기존에 사용하던 <code>$:</code> 문법은 작성하기엔 무척 편리했지만, 프로젝트가 커질수록 어떤 값이 어디에 영향을 미치는지 파악하기 모호해지는 프로그래밍적 복잡성이 존재했습니다. 룬은 코드의 의도를 한층 더 명확하게 드러내어, 개발자가 데이터의 흐름을 쉽게 예측할 수 있도록 도와줍니다.</li></ul>",1);function R(t){var e=b();d(12),p(t,e)}const U=Object.freeze(Object.defineProperty({__proto__:null,default:R,metadata:v},Symbol.toStringTag,{value:"Module"}));export{U as _,x as a};
